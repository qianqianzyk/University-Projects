# 计算机组成原理课程设计 - 基于8位模型机的组合数计算

## 项目简介

本项目是计算机组成原理课程的期末课程设计。项目目标是综合运用所学知识，设计并实现一套较为完整的计算机指令系统，并在8位模型机硬件平台上编写程序，实现**组合数 C(n, m)** 的计算功能

由于实验所用的基础模型机运算器仅支持加减法，本项目的一个核心难点在于**通过微程序设计扩展指令系统**，利用移位（Shift）和加减法（Add/Sub）在软件层面模拟**乘法**和**除法**运算，从而完成复杂的组合数求解

## 核心特性

- **自定义指令系统**: 扩展了标准模型机的指令集，新增了 `CMP` (比较)、`TEST` (逻辑测试)、`SHL` (逻辑左移)、`SHR` (逻辑右移) 四条指令
- **软硬件协同设计**: 编写了完整的微程序（Microcode）和机器码（Machine Code）
- **复杂运算模拟**:
  - **乘法**: 采用“移位-加法”算法模拟
  - **除法**: 采用“减法循环”算法模拟
- **C++ 仿真验证**: 提供了 C++ 版本的模拟程序，用于验证汇编逻辑和算法的正确性

## 仓库结构

Plaintext

```
├── 计算机组成原理课程设计报告.pdf      # 完整的课程设计报告（含详细原理、步骤与答辩Q&A）
├── 计算机组成原理课程设计/
│   ├── soruce_code.cpp             # C++ 仿真代码（用于验证汇编逻辑）
│   ├── source_code.TXT             # 机器指令代码 (可直接用于加载)
│   ├── 指令框图(www.processon.com).pos  # 指令周期流程图源文件
│   └── 流程图(www.processon.com).pos    # 主程序逻辑流程图源文件
└── README.md                       # 项目说明文档
```

## 指令系统设计

为了实现乘除法运算，本项目对原有模型机指令进行了改造，替换了未使用的 AND、OR 等指令。最终设计的指令集如下（共16条）：

| **助记符**      | **机器码 (高4位)** | **功能描述**        | **备注**                            |
| --------------- | ------------------ | ------------------- | ----------------------------------- |
| **MOV** RD, RS  | `0100`             | RS -> RD            | 寄存器传输                          |
| **ADD** RD, RS  | `0000`             | RD + RS -> RD       | 加法                                |
| **SUB** RD, RS  | `1000`             | RD - RS -> RD       | 减法                                |
| **CMP** RD, RS  | `1011`             | RD - RS             | **新增**: 比较 (只影响标志位)       |
| **TEST** RD, RS | `0001`             | RD & RS             | **新增**: 逻辑与测试 (只影响标志位) |
| **SHR** RD      | `1001`             | RD >> 1             | **新增**: 逻辑右移                  |
| **SHL** RD      | `1010`             | RD << 1             | **新增**: 逻辑左移                  |
| **INC** RD      | `0111`             | RD + 1 -> RD        | 自增                                |
| **LAD** M, D    | `1100`             | M[D] -> RD          | 读内存                              |
| **STA** M, D    | `1101`             | RS -> M[D]          | 写内存                              |
| **JMP** M, D    | `1110`             | D -> PC             | 无条件跳转                          |
| **BZC** M, D    | `1111`             | 若 FZ/FC=1, D -> PC | 条件跳转 (零标志/进位)              |
| **IN** RD, P    | `0010`             | Input[P] -> RD      | 输入                                |
| **OUT** P, RS   | `0011`             | RS -> Output[P]     | 输出                                |
| **LDI** RD, D   | `0110`             | D -> RD             | 立即数加载                          |
| **HLT**         | `0101`             | 停机                | 程序结束                            |

> **注**: `RD` 为目的寄存器，`RS` 为源寄存器，`M` 代表内存地址操作。

## 算法原理

组合数公式为
$$
C(n,m) = \frac{n!}{m!(n-m)!}
$$
为了避免阶乘导致的数值溢出，并适应8位机（0-255）的限制，本设计采用了迭代法计算：
$$
res = \frac{res \times (n - m + i)}{i}
$$
其中 i 从 1 循环到 m

### C++ 模拟逻辑

`soruce_code.cpp` 文件完整模拟了汇编程序的执行流程，特别是使用了 `goto` 语句来对应汇编中的 `JMP` 和 `BZC` 跳转，方便理解程序流

- **乘法模拟 (`MUL`)**: 判断乘数最低位是否为1（`TEST`指令），若是则累加被乘数；然后被乘数左移（`SHL`），乘数右移（`SHR`）
- **除法模拟 (`DIV`)**: 采用重复减法，统计减去的次数作为商

## 使用说明

### 1. 微程序加载

根据报告中的 **表2 微程序二进制代码表**，将微指令代码写入实验箱的控制存储器（地址 `00` - `3F`）

- 关键修改点：`3B` 处写入 CMP 微程序，`31` 处写入 TEST 微程序，`39`/`3A` 分别写入 SHR/SHL

### 2. 机器程序加载

根据报告中的 **表3 机器程序表**，将机器指令写入主存

- **程序入口**: `00`
- **数据区**: `60H`, `61H`, `62H` 用于临时存储中间变量

### 3. 运行测试

1. 启动运行，程序暂停等待输入
2. **输入 n**: 通过输入开关设置 n 的值（如 `0000 0100` 即 4），按单脉冲确认
3. **输入 m**: 通过输入开关设置 m 的值（如 `0000 0001` 即 1），按单脉冲确认
4. 程序运行结束，输出结果显示在 LED 或数码管上

**示例**:

- 输入 n=4, m=1-> 输出 `04`
- 输入 n=6, m=2 -> 输出 `0F` (即十进制 15)